var searchIndex = {};
searchIndex["rgb"] = {"doc":"Basic struct for `RGB` and `RGBA` pixels. Packed, with red first, alpha last.","items":[[3,"RGB","rgb","This is it. The component type can be `u8` (aliased as `RGB8`), `u16` (aliased as `RGB16`), or any other type (but simple copyable types are recommended.)",null,null],[12,"r","","Red",0,null],[12,"g","","Green",0,null],[12,"b","","Blue",0,null],[3,"RGBA","","This is it. The component type can be `u8` (aliased as `RGBA8`), `u16` (aliased as `RGBA16`), or any other type (but simple copyable types are recommended.)",null,null],[12,"r","","Red",1,null],[12,"g","","Green",1,null],[12,"b","","Blue",1,null],[12,"a","","Alpha",1,null],[11,"new","","Convenience function for creating a new pixel",0,{"inputs":[{"name":"t"},{"name":"t"},{"name":"t"}],"output":{"name":"self"}}],[11,"iter","","Iterate over color components (R, G, and B)",0,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"alpha","","",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"rgba"}}],[11,"new_alpha","","",0,{"inputs":[{"name":"self"},{"name":"a"}],"output":{"name":"rgba"}}],[11,"map","","",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"rgb"}}],[11,"as_slice","","",0,null],[11,"as_mut_slice","","",0,null],[11,"from_iter","","Takes exactly 3 elements from the iterator and creates a new instance. Panics if there are fewer elements in the iterator.",0,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",1,{"inputs":[{"name":"t"},{"name":"t"},{"name":"t"},{"name":"t"}],"output":{"name":"self"}}],[11,"iter","","Iterate over all components (length=4)",1,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"rgb","","Copy RGB components out of the RGBA struct",1,{"inputs":[{"name":"self"}],"output":{"name":"rgb"}}],[11,"rgb_mut","","Provide a mutable view of only RGB components (leaving out alpha). Useful to change color without changing opacity.",1,{"inputs":[{"name":"self"}],"output":{"name":"rgb"}}],[11,"map_rgb","","Create new RGBA with the same alpha value, but different RGB values",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"rgba"}}],[11,"map","","",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"rgba"}}],[11,"as_slice","","",1,null],[11,"as_mut_slice","","",1,null],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"add","","",0,null],[11,"add","","",1,null],[11,"sub","","",0,null],[11,"sub","","",1,null],[11,"add","","",0,null],[11,"add","","",1,null],[11,"mul","","",0,null],[11,"mul","","",1,null],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rgb"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"rgba"}],"output":{"name":"self"}}],[6,"RGB8","","8-bit RGB. The colorspace is techincally undefined, but generally sRGB is assumed.",null,null],[6,"RGB16","","16-bit RGB in machine's native endian. Be careful to perform byte-swapping when reading from files.",null,null],[6,"RGBA8","","Alpha is last. The crate doesn't impose which value represents transparency, but usually it's 0 = transparent, 255 = opaque.",null,null],[6,"RGBA16","","16-bit RGB in machine's native endian. Alpha is last.",null,null],[8,"ComponentBytes","","Casting the struct to slices/bytes of its components",null,null],[10,"as_slice","","The components interpreted as an array, e.g. RGB gives 3-element slice. The red component is first.",2,null],[10,"as_mut_slice","","",2,null],[11,"as_bytes","","The components interpreted as raw bytes, in machine's native endian. Bytes of the red component are first.",2,null],[8,"ComponentMap","","Applying operation to every component",null,null],[10,"map","","Convenience function (equivalent of `self.iter().map().collect()`) for applying the same formula to every component.",3,{"inputs":[{"name":"self"},{"name":"callback"}],"output":{"name":"destpixel"}}],[8,"FromSlice","","Cast a slice of component values (bytes) as a slice of RGB/RGBA pixels",null,null],[10,"as_rgb","","",4,null],[10,"as_rgba","","",4,null],[10,"as_rgb_mut","","",4,null],[10,"as_rgba_mut","","",4,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"rgb"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"rgb"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"rgb"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"rgba"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"rgba"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"rgba"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"as_bytes","","The components interpreted as raw bytes, in machine's native endian. Bytes of the red component are first.",2,null]],"paths":[[3,"RGB"],[3,"RGBA"],[8,"ComponentBytes"],[8,"ComponentMap"],[8,"FromSlice"]]};
initSearch(searchIndex);
